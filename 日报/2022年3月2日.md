## 周三

> 10-17点 看Array.flat( ) 方法 并且用reduce 实现



```js
// 用reduce 进行模拟

var arr2 = [1, 2, 3, [1, 2, 3, 4, [2, 3, 4]]];
function flat(arr, num = 1) {
	return num > 0 ? arr.reduce((prev, cur) => {
		console.log(prev, cur);
        return prev.concat(Array.isArray(cur) ? flat(cur, num - 1) : cur)}, []) : arr.slice();
        }
console.log(flat(arr2, 2));
//这个方法需要两个参数 一个是数组 一个是 迭代的深度(默认给他1)
1. 先判断 num是否大于0, 如果大于0的话直接，调用reduce方法，num = 0的话,arr.slice( ) 返回原来的数组 
2. num大于0,将传进来的数组调用reduce方法,reduce方法 穿两个参数((prev,cur),[ ])给prev为[ ] 
3. 用prev.concat((Array.isArray(cur) ? flat(cur, num - 1) : cur)  
                
//在concat里面判断cur是不是数组 不是数组那么直接concat进去，否则进行递归调用 flat将cur直接穿进去 然后num-1 
4.开始调用falt(arr,2),num大于0 向下执行,arr.reduce([],1) 直接concat 一直走到第三位可以直接concat，然后第四位是个数组开始第二次调用，现在arr = [1,2,3]
4.第二次调用falt(cur,num-1) 然后返回出来的数据就是,[1, 2, 3, 4, [2, 3, 4]];
5.第三次调用falt[2, 3, 4]
6.第一次concat第二次的返回值 第二次concat第三次的返回值
```

### 用forEarch +Array.isAarray()+ 递归+匿名函数自调实现

```js
const arr1 = [1,2,3,[4,5,[6,7,8]]];
function flat(arr,num = 1){
    const result = [];
    ( function flat1(arr,num){
        // forEach 遍历,item如果不是数组直接push进去,
        //itme 是数组的话 且 num > 0 继续forEach遍历 
        arr.forEach((item)=>{
           if(Array.isArray(item) && num>0){
               flat1(item,num - 1)
           }else{
               result.push(item);
           }
        })
    })(arr,num)
    return result;
} 
console.log(flat(arr1,2));
```

> 17 